## 🐋 Dart List 

### 📝 Overview

In Dart, a **List** is an ordered collection of items that you can access by index. It is similar to arrays in other languages, but it comes with powerful built-in methods that make it more versatile.

### 🎯 Purpose

To store multiple items of the same type in a single variable and perform various operations like add, remove, iterate, sort, etc.

---

### 🔧 Creating a List

```dart
List<String> names = ['Dokja', 'Jeha', 'Hamin'];
List<int> numbers = [1, 2, 3, 4, 5];
var mixed = [1, 'hello', true]; // dynamic type
final fixed = [10, 20]; // cannot reassign, but can modify contents
const immutable = [1, 2, 3]; // fully immutable
```

### ✅ Empty List

```dart
List<String> emptyList = [];
List<int> fixedLengthList = List.filled(5, 0); // [0, 0, 0, 0, 0]
```

### 🧪 Accessing Elements

```dart
print(names[0]); // Dokja
print(numbers[2]); // 3
```

### ✏️ Modifying Elements

```dart
names[1] = 'Dazai';
print(names); // ['Dokja', 'Dazai', 'Hamin']
```

---

### ➕ Adding Items

```dart
names.add('Ahn'); // Add single element
names.addAll(['Kim', 'Park']); // Add multiple elements
```

### ➖ Removing Items

```dart
names.remove('Jeha'); // Remove by value
names.removeAt(0); // Remove by index
names.clear(); // Remove all items
```

### 🔍 Searching & Checking

```dart
print(names.contains('Dokja')); // true or false
print(names.indexOf('Dokja')); // Index or -1
```

---

### 🔁 Looping through List

```dart
for (var name in names) {
  print(name);
}

names.forEach((name) => print(name));

for (int i = 0; i < names.length; i++) {
  print(names[i]);
}
```

---

### 📐 List Properties

```dart
print(names.length); // Number of elements
print(names.isEmpty); // true or false
print(names.isNotEmpty); // true or false
```

---

### 🧰 Useful Methods

```dart
List<int> a = [1, 2, 3];
List<int> b = [4, 5];

print(a + b); // Concatenation: [1, 2, 3, 4, 5]
a.insert(1, 99); // [1, 99, 2, 3]
a.insertAll(2, [88, 77]); // [1, 99, 88, 77, 2, 3]
a.addAll([100, 200]); // [1, 99, 88, 77, 2, 3, 100, 200]
a.sort(); // Sort in ascending order
a = a.reversed.toList(); // Reverse list
```

### 🧪 Filtering List

```dart
var evens = [1, 2, 3, 4, 5, 6].where((x) => x % 2 == 0).toList();
print(evens); // [2, 4, 6]
```

---

### 🔄 Manipulating List Data

```dart
var list = [1, 2, 3];

// Replace range of elements
list.replaceRange(0, 2, [99, 88]);
print(list); // [99, 88, 3]

// Remove range
list.removeRange(0, 1);
print(list); // [88, 3]

// Fill range
list.fillRange(0, 2, 0);
print(list); // [0, 0]

// Set all elements
list.setAll(0, [7, 8]);
print(list); // [7, 8]
```

---

### 🔐 Using `var`, `final`, and `const` with List

```dart
var list1 = [1, 2, 3]; // Mutable and reassignable
final list2 = [4, 5, 6]; // Cannot reassign, but contents can be modified
const list3 = [7, 8, 9]; // Fully immutable

list1.add(10); // ✅ Allowed
list2[0] = 99; // ✅ Allowed
list2 = [0]; // ❌ Error: can't reassign final variable
list3[0] = 77; // ❌ Error: const list is unmodifiable
```

---

### 🧱 Immutable List

```dart
final constList = List.unmodifiable([1, 2, 3]);
constList.add(4); // Error! Cannot modify
```

---

### 📌 Spread Operator

```dart
var list1 = [1, 2];
var list2 = [0, ...list1, 3];
print(list2); // [0, 1, 2, 3]
```

### ❓ Null-aware Spread

```dart
List<int>? a;
var b = [0, ...?a];
print(b); // [0]
```

---

### 🔄 Copying List

```dart
var original = [1, 2, 3];
var copy = [...original];
```

---

### 🧮 List Map & Reduce

#### 🔄 Map

Use `.map()` to apply a function to each element and return a new iterable.

```dart
var numbers = [1, 2, 3];
var doubled = numbers.map((x) => x * 2).toList();
print(doubled); // [2, 4, 6]
```

#### ➕ Reduce

Use `.reduce()` to accumulate the list values into a single result.

```dart
var numbers = [1, 2, 3, 4];
var sum = numbers.reduce((a, b) => a + b);
print(sum); // 10
```

#### 📊 Fold

Similar to `reduce`, but allows an initial value.

```dart
var numbers = [1, 2, 3, 4];
var total = numbers.fold(10, (prev, curr) => prev + curr);
print(total); // 20
```

---

### 🧠 Tips

* Lists in Dart are **zero-indexed**.
* Use `List.generate(length, (index) => value)` for custom list generation.
* Use `asMap()` to convert a list into a map with index-value pairs.

```dart
var map = ['a', 'b', 'c'].asMap();
print(map); // {0: a, 1: b, 2: c}
```

---

### 🧪 List.generate Example

```dart
var squares = List.generate(5, (i) => i * i);
print(squares); // [0, 1, 4, 9, 16]
```

---

### 🧪 Difference Between `List.filled()` vs `List.generate()`

Both are used to create lists of a certain length, but behave differently when filling values:

```dart
// List.filled: Fills with the same value (same reference if object)
var list1 = List.filled(3, []);
list1[0].add(1);
print(list1); // [[1], [1], [1]]

// List.generate: Generates new value on each call
var list2 = List.generate(3, (_) => []);
list2[0].add(1);
print(list2); // [[1], [], []]
```

### 🧠 Note

* `List.filled(length, value)` fills all indexes with the **same reference** if the value is an object.
* `List.generate(length, (index) => ...)` executes the function for **each element**, so each index holds a **different object in memory**.

---

### ✅ Summary

| Operation       | Example                  | Description             |
| --------------- | ------------------------ | ----------------------- |
| Add element     | `list.add(3)`            | Add a single element    |
| Add many        | `list.addAll([4, 5])`    | Add multiple elements   |
| Remove element  | `list.remove(3)`         | Remove specific value   |
| Insert element  | `list.insert(1, 99)`     | Insert at index         |
| Access element  | `list[0]`                | Get value at index      |
| Loop            | `for`, `forEach`         | Traverse list           |
| Check existence | `list.contains(3)`       | Check if element exists |
| Sorting         | `list.sort()`            | Sort list               |
| Reversing       | `list.reversed.toList()` | Reverse the list        |
| Filtering       | `list.where((x)=>...)`   | Create filtered list    |

---

📌 **Lists are powerful and flexible** in Dart. Mastering their operations is key to handling data effectively in Flutter and Dart-based applications.
